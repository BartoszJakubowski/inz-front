{"ast":null,"code":"import { ERROR_CODE_NOT_AUTHORIZED, ERROR_CODE_NOT_VALIDATED, ERROR_MSG_CRITICAL, ERROR_MSG_VALIDATION, ERROR_MSG_NOT_AUTHOIZED } from 'consts/errors';\nexport var mapErrors = function mapErrors(responseBody) {\n  // Set validation errors\n  var validationErrors = {};\n\n  try {\n    var _responseBody$data;\n\n    validationErrors = ((_responseBody$data = responseBody.data) === null || _responseBody$data === void 0 ? void 0 : _responseBody$data.errors) || {};\n    Object.keys(validationErrors).forEach(function (field) {\n      var finalKey = field.split('.');\n      var finalKeyString = finalKey[0];\n      validationErrors[finalKeyString] = Array.isArray(validationErrors[field]) ? validationErrors[field].join(',') : validationErrors[field];\n    });\n  } catch (error) {\n    validationErrors = {};\n  } // Set error message\n\n\n  var errorMessage = ERROR_MSG_CRITICAL;\n\n  try {\n    switch (responseBody.status) {\n      case ERROR_CODE_NOT_VALIDATED:\n        errorMessage = ERROR_MSG_VALIDATION;\n        break;\n\n      case ERROR_CODE_NOT_AUTHORIZED:\n        errorMessage = ERROR_MSG_NOT_AUTHOIZED;\n        break;\n\n      default:\n        errorMessage = responseBody.msg && responseBody.msg.message || ERROR_MSG_CRITICAL;\n        break;\n    }\n  } catch (error) {\n    errorMessage = ERROR_MSG_CRITICAL;\n  }\n\n  return {\n    originalError: responseBody || null,\n    statusText: (responseBody === null || responseBody === void 0 ? void 0 : responseBody.statusText) || 'ERROR',\n    code: (responseBody === null || responseBody === void 0 ? void 0 : responseBody.status) || 0,\n    message: errorMessage,\n    validationErrors: validationErrors || {}\n  };\n};","map":{"version":3,"sources":["/home/bartosz/Pulpit/inz/my-app/src/utils/api.ts"],"names":["ERROR_CODE_NOT_AUTHORIZED","ERROR_CODE_NOT_VALIDATED","ERROR_MSG_CRITICAL","ERROR_MSG_VALIDATION","ERROR_MSG_NOT_AUTHOIZED","mapErrors","responseBody","validationErrors","data","errors","Object","keys","forEach","field","finalKey","split","finalKeyString","Array","isArray","join","error","errorMessage","status","msg","message","originalError","statusText","code"],"mappings":"AAAA,SACIA,yBADJ,EAEIC,wBAFJ,EAGIC,kBAHJ,EAIIC,oBAJJ,EAKIC,uBALJ,QAMO,eANP;AAUA,OAAO,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACC,YAAD,EAAsD;AAC3E;AACA,MAAIC,gBAAgB,GAAG,EAAvB;;AACA,MAAI;AAAA;;AACAA,IAAAA,gBAAgB,GAAG,uBAAAD,YAAY,CAACE,IAAb,0EAAmBC,MAAnB,KAA6B,EAAhD;AACAC,IAAAA,MAAM,CAACC,IAAP,CAAYJ,gBAAZ,EAA8BK,OAA9B,CAAsC,UAACC,KAAD,EAAmB;AACrD,UAAMC,QAAQ,GAAGD,KAAK,CAACE,KAAN,CAAY,GAAZ,CAAjB;AACA,UAAMC,cAAc,GAAGF,QAAQ,CAAC,CAAD,CAA/B;AACAP,MAAAA,gBAAgB,CAACS,cAAD,CAAhB,GAAmCC,KAAK,CAACC,OAAN,CAAcX,gBAAgB,CAACM,KAAD,CAA9B,IAC7BN,gBAAgB,CAACM,KAAD,CAAhB,CAAwBM,IAAxB,CAA6B,GAA7B,CAD6B,GAE7BZ,gBAAgB,CAACM,KAAD,CAFtB;AAGH,KAND;AAOH,GATD,CASE,OAAOO,KAAP,EAAc;AACZb,IAAAA,gBAAgB,GAAG,EAAnB;AACH,GAd0E,CAgB3E;;;AACA,MAAIc,YAAY,GAAGnB,kBAAnB;;AACA,MAAI;AACA,YAAQI,YAAY,CAACgB,MAArB;AACI,WAAKrB,wBAAL;AACIoB,QAAAA,YAAY,GAAGlB,oBAAf;AACA;;AACJ,WAAKH,yBAAL;AACIqB,QAAAA,YAAY,GAAGjB,uBAAf;AACA;;AACJ;AACIiB,QAAAA,YAAY,GAAGf,YAAY,CAACiB,GAAb,IAAoBjB,YAAY,CAACiB,GAAb,CAAiBC,OAArC,IAAgDtB,kBAA/D;AACA;AATR;AAWH,GAZD,CAYE,OAAOkB,KAAP,EAAc;AACZC,IAAAA,YAAY,GAAGnB,kBAAf;AACH;;AAED,SAAO;AACHuB,IAAAA,aAAa,EAAEnB,YAAY,IAAI,IAD5B;AAEHoB,IAAAA,UAAU,EAAE,CAAApB,YAAY,SAAZ,IAAAA,YAAY,WAAZ,YAAAA,YAAY,CAAEoB,UAAd,KAA4B,OAFrC;AAGHC,IAAAA,IAAI,EAAE,CAAArB,YAAY,SAAZ,IAAAA,YAAY,WAAZ,YAAAA,YAAY,CAAEgB,MAAd,KAAwB,CAH3B;AAIHE,IAAAA,OAAO,EAAEH,YAJN;AAKHd,IAAAA,gBAAgB,EAAEA,gBAAgB,IAAI;AALnC,GAAP;AAOH,CAzCM","sourcesContent":["import {\n    ERROR_CODE_NOT_AUTHORIZED,\n    ERROR_CODE_NOT_VALIDATED,\n    ERROR_MSG_CRITICAL,\n    ERROR_MSG_VALIDATION,\n    ERROR_MSG_NOT_AUTHOIZED,\n} from 'consts/errors';\n\nimport { ApiResponseBody, ApiResponseErrors } from 'types/request';\n\nexport const mapErrors = (responseBody: ApiResponseBody): ApiResponseErrors => {\n    // Set validation errors\n    let validationErrors = {};\n    try {\n        validationErrors = responseBody.data?.errors || {};\n        Object.keys(validationErrors).forEach((field: string) => {\n            const finalKey = field.split('.');\n            const finalKeyString = finalKey[0];\n            validationErrors[finalKeyString] = Array.isArray(validationErrors[field])\n                ? validationErrors[field].join(',')\n                : validationErrors[field];\n        });\n    } catch (error) {\n        validationErrors = {};\n    }\n\n    // Set error message\n    let errorMessage = ERROR_MSG_CRITICAL;\n    try {\n        switch (responseBody.status) {\n            case ERROR_CODE_NOT_VALIDATED:\n                errorMessage = ERROR_MSG_VALIDATION;\n                break;\n            case ERROR_CODE_NOT_AUTHORIZED:\n                errorMessage = ERROR_MSG_NOT_AUTHOIZED;\n                break;\n            default:\n                errorMessage = responseBody.msg && responseBody.msg.message || ERROR_MSG_CRITICAL;\n                break;\n        }\n    } catch (error) {\n        errorMessage = ERROR_MSG_CRITICAL;\n    }\n\n    return {\n        originalError: responseBody || null,\n        statusText: responseBody?.statusText || 'ERROR',\n        code: responseBody?.status || 0,\n        message: errorMessage,\n        validationErrors: validationErrors || {},\n    };\n};\n"]},"metadata":{},"sourceType":"module"}