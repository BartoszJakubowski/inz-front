{"ast":null,"code":"import { ERROR_CODE_NOT_AUTHORIZED, ERROR_CODE_NOT_VALIDATED, ERROR_MSG_CRITICAL, ERROR_MSG_VALIDATION, ERROR_MSG_NOT_AUTHOIZED } from 'consts/errors';\nexport const mapErrors = responseBody => {\n  // Set validation errors\n  let validationErrors = {};\n\n  try {\n    var _responseBody$data;\n\n    validationErrors = ((_responseBody$data = responseBody.data) === null || _responseBody$data === void 0 ? void 0 : _responseBody$data.errors) || {};\n    Object.keys(validationErrors).forEach(field => {\n      const finalKey = field.split('.');\n      const finalKeyString = finalKey[0];\n      validationErrors[finalKeyString] = Array.isArray(validationErrors[field]) ? validationErrors[field].join(',') : validationErrors[field];\n    });\n  } catch (error) {\n    validationErrors = {};\n  } // Set error message\n\n\n  let errorMessage = ERROR_MSG_CRITICAL;\n\n  try {\n    switch (responseBody.status) {\n      case ERROR_CODE_NOT_VALIDATED:\n        errorMessage = ERROR_MSG_VALIDATION;\n        break;\n\n      case ERROR_CODE_NOT_AUTHORIZED:\n        errorMessage = ERROR_MSG_NOT_AUTHOIZED;\n        break;\n\n      default:\n        errorMessage = responseBody.msg && responseBody.msg.message || ERROR_MSG_CRITICAL;\n        break;\n    }\n  } catch (error) {\n    errorMessage = ERROR_MSG_CRITICAL;\n  }\n\n  return {\n    originalError: responseBody || null,\n    statusText: (responseBody === null || responseBody === void 0 ? void 0 : responseBody.statusText) || 'ERROR',\n    code: (responseBody === null || responseBody === void 0 ? void 0 : responseBody.status) || 0,\n    message: errorMessage,\n    validationErrors: validationErrors || {}\n  };\n};","map":null,"metadata":{},"sourceType":"module"}