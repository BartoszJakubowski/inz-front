{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport getConfig from 'next/config';\nimport axios from 'axios';\nimport { INIT_FLAG, SUCCESS_FLAG, FAIL_FLAG } from 'consts/redux';\nimport { parseToQueryString } from 'utils/querystring';\nimport { mapErrors } from 'utils/api';\nimport Logger from 'services/Logger';\nexport var reduxRequest = function reduxRequest(options) {\n  return function (dispatch) {\n    var storeState = options.getState();\n    options = transformOptions(options, storeState);\n\n    if (!options.ignoreState) {\n      dispatch({\n        state: INIT_FLAG,\n        type: options.reduxType + '_' + INIT_FLAG,\n        params: options.params\n      });\n    }\n\n    return new Promise(function (resolve, reject) {\n      var requestConfig = getRequestCofnig(options); // Logger.log('API Request', {\n      //     url: requestConfig.url,\n      //     options: options,\n      //     requestConfig: requestConfig,\n      // });\n\n      return axios(requestConfig).then(function (response) {\n        // Logger.log('API Response', options, response);\n        if (options.actionsOnCode && options.actionsOnCode[response.status]) {\n          options.actionsOnCode[response.status](response);\n        }\n\n        return resolve(options.ignoreState ? {\n          state: SUCCESS_FLAG,\n          type: options.reduxType + '_' + SUCCESS_FLAG,\n          payload: response,\n          params: options.params\n        } : dispatch({\n          state: SUCCESS_FLAG,\n          type: options.reduxType + '_' + SUCCESS_FLAG,\n          payload: response,\n          params: options.params\n        }));\n      })[\"catch\"](function (error) {\n        console.error(error && error.response || error);\n\n        try {\n          var _error$response;\n\n          Logger.warning('API Error', {\n            options: options,\n            response: error.response\n          });\n\n          if (options.actionsOnCode && options.actionsOnCode[error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status]) {\n            var _error$response2;\n\n            options.actionsOnCode[error === null || error === void 0 ? void 0 : (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status](error === null || error === void 0 ? void 0 : error.response);\n          }\n\n          return reject(options.ignoreState ? {\n            state: FAIL_FLAG,\n            type: options.reduxType + '_' + FAIL_FLAG,\n            payload: mapErrors(error && error.response),\n            params: options.params\n          } : dispatch({\n            state: FAIL_FLAG,\n            type: options.reduxType + '_' + FAIL_FLAG,\n            payload: mapErrors(error && error.response),\n            params: options.params\n          }));\n        } catch (error) {\n          Logger.error('API Network Error', {\n            options: options,\n            error: error\n          });\n          return reject(options.ignoreState ? {\n            state: FAIL_FLAG,\n            type: options.reduxType + '_' + FAIL_FLAG,\n            payload: mapErrors(error && error.response),\n            params: options.params\n          } : dispatch({\n            state: FAIL_FLAG,\n            type: options.reduxType + '_' + FAIL_FLAG,\n            payload: mapErrors(error && error.response),\n            params: options.params\n          }));\n        }\n      });\n    });\n  };\n}; // export function redirectToApiEndpoint(path) {\n//     const store = initializeStore({});\n//     const storeState = store.getState();\n//     const apiUrl = parseToQueryString(process.env.API_URL + path, {\n//         authToken: storeState.user.authToken,\n//     });\n//     const win = window.open(\n//         apiUrl,\n//         '_blank'\n//     );\n//     win.focus();\n// }\n\nfunction getRequestCofnig(options) {\n  return {\n    method: options.method.toUpperCase(),\n    url: options.url,\n    headers: _objectSpread({\n      'Content-Type': 'application/json; charset=UTF-8'\n    }, options.headers),\n    data: options.data,\n    timeout: options.timeout || 10000,\n    responseType: 'json',\n    adapter: options.adapter || undefined,\n    validateStatus: function validateStatus(status) {\n      return status >= 200 && status < 300;\n    },\n    paramsSerializer: function paramsSerializer(params) {\n      return JSON.stringify(params);\n    }\n  };\n}\n\nfunction transformOptions(options, storeState) {\n  var _storeState$user;\n\n  var _getConfig = getConfig(),\n      publicRuntimeConfig = _getConfig.publicRuntimeConfig; // Attach headers\n\n\n  options.headers = _objectSpread({}, options.headers || {});\n\n  if ((_storeState$user = storeState.user) !== null && _storeState$user !== void 0 && _storeState$user.authToken) {\n    options.headers = _objectSpread(_objectSpread({}, options.headers), {}, {\n      'authorization': 'Bearer ' + storeState.user.authToken\n    });\n  } // Ensure that requestParams is object\n\n\n  if (typeof options.requestParams !== 'object' || !options.requestParams) {\n    options.requestParams = {};\n  } // Support for PUT request methods\n\n\n  if (options.method.toUpperCase() === 'PUT' && !options.forceMethod) {\n    options.method = 'POST';\n    options.requestParams._method = 'PUT';\n  } // Support for DELETE request methods\n\n\n  if (options.method.toUpperCase() === 'DELETE' && !options.forceMethod) {\n    options.method = 'POST';\n    options.requestParams._method = 'DELETE';\n  }\n\n  if (options.method.toUpperCase() === 'GET') {\n    options.path = parseToQueryString(options.path, options.requestParams);\n  }\n\n  options.data = options.requestParams;\n\n  if (options.asFormData) {\n    var formData = new FormData();\n    Object.keys(options.data).forEach(function (key) {\n      formData.append(key, options.data[key]);\n    });\n    options.data = formData;\n  } // Get api path\n\n\n  options.url = publicRuntimeConfig.API_URL + options.path;\n\n  if (options.apiUrl) {\n    options.url = options.apiUrl + options.path;\n  }\n\n  return options;\n}","map":null,"metadata":{},"sourceType":"module"}